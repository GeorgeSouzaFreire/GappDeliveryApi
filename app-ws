const WebSocket = require('ws');

function onError(ws, err) {
    console.error(`onError: ${err.message}`);
}

function onMessage(ws, data) {
    console.log(`onMessage: ${data}`);
    console.log(ws.clients);
    if (!ws.clients) return;
    ws.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({ data }));
        }
    });
    ws.send(`recebido!`);
}

function onConnection(ws, req) {
    ws.on('message', data => onMessage(ws, data));
    ws.on('error', error => onError(ws, error));
    console.log(`onConnection`);
}

function corsValidation(origin) {
    return process.env.CORS_ORIGIN === '*' || process.env.CORS_ORIGIN.startsWith(origin);
}

function verifyClient(info, callback) {
    /*if (!corsValidation(info.origin)) return callback(false);

    const token = info.req.url.split('token=')[1];

    console.log(token);

    if (token) {
        if (token === process.env.GAPP_DELYVERY_ACCESS_KEY_SECRET)
            return callback(true);
    }*/

    return callback(true);
}

const users = [];

// Broadcast to all connected clients
const broadcast = (data, ws) => {
    wss.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN && client !== ws) {
            client.send(JSON.stringify(data));
        }
    });
};

/*function broadcast(jsonObject) {
    console.log(jsonObject);
    console.log(this.clients);
    if (!this.clients) return;
    this.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify(jsonObject));
        }
    });
}*/

module.exports = (server) => {
    const wss = new WebSocket.Server({ server, verifyClient });

    // When web socket forms a connections
    wss.on("connection", ws => {
        let index;
        ws.on("message", message => {
            const data = JSON.parse(message);
            switch (data.type) {
                case "ADD_USER":
                    index = users.length;
                    users.push({ name: data.name, id: index + 1 });
                    ws.send(JSON.stringify({ type: "USERS_LIST", users }));
                    broadcast({ type: "USERS_LIST", users }, ws);
                    break;
                case "ADD_MESSAGE":
                    // Everybody connected to the server gets that message
                    broadcast(
                        {
                            type: "ADD_MESSAGE",
                            message: data.message,
                            author: data.author
                        },
                        ws
                    );
                    break;
                default:
                    break;
            }
        });
        // When websocket closes, it closes the user for that user list (splices to remove user).
        wss.on("close", () => {
            users.splice(index, 1);
            broadcast({ type: "USERS_LIST", users }, ws);
        });
    });

    //wss.on('connection', onConnection);
    //wss.broadcast = broadcast;
    //console.log(`App Web Socket Server is running!`);
    return wss;
}